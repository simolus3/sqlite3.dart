import 'dart:io';

import 'package:dart_style/dart_style.dart';
import 'package:ffigen/ffigen.dart';
import 'package:ffigen/src/config_provider/config_types.dart';
import 'package:ffigen/src/config_provider/spec_utils.dart';
import 'package:ffigen/src/code_generator.dart';
import 'package:ffigen/src/header_parser.dart' as ffigen;
import 'package:pub_semver/pub_semver.dart';

import '../../sqlite3_wasm_build/tool/wasm_symbols.dart';

void main() {
  _ffigen();
  writeUsedSymbols();
  writeWasmDefinitions();
}

void _ffigen() {
  final libraryImports = <String, LibraryImport>{};
  final generator = FfiGen();
  final config = Config(
    preamble: '// ignore_for_file: type=lint',
    ffiNativeConfig: FfiNativeConfig(
      enabled: true,
      assetId: 'package:sqlite3/src/ffi/libsqlite3.g.dart',
    ),
    output: Uri.parse('lib/src/ffi/libsqlite3.g.dart'),
    entryPoints: [Uri.parse('assets/sqlite3.h')],
    symbolFile: null,
    structDecl: _includeSqlite3Only,
    functionDecl: _includeSqlite3Only,
    globals: _includeSqlite3Only,
    varArgFunctions: makeVarArgFunctionsMapping({
      'sqlite3_db_config': [
        RawVarArgFunction('', ['int', 'int*']),
      ],
    }, libraryImports),
    libraryImports: libraryImports.values.toList(),
  );

  generator.run(config);
}

DeclarationFilters _includeSqlite3Only = DeclarationFilters(
  shouldInclude: (d) => d.isSqlite3Symbol,
  shouldIncludeSymbolAddress: (decl) {
    return switch (decl.originalName) {
      'sqlite3changeset_finalize' => true,
      'sqlite3session_delete' => true,
      'sqlite3_free' => true,
      _ => false,
    };
  },
);

extension on Declaration {
  bool get isSqlite3Symbol => originalName.startsWith('sqlite3');
}

void writeWasmDefinitions() {
  final filter = DeclarationFilters(
    shouldInclude: (d) =>
        stableFunctions.contains(d.originalName) ||
        unstable.contains(d.originalName),
  );

  final library = ffigen.parse(
    Config(
      output: Uri.parse('unused'),
      entryPoints: [
        Uri.parse('assets/sqlite3.h'),
        Uri.parse('assets/sqlite3_dart_wasm.h'),
      ],
      functionDecl: filter,
      globals: filter,
    ),
  );
  final buffer = StringBuffer('''
import 'dart:js_interop';

import 'js_interop.dart';

// ignore_for_file: non_constant_identifier_names
typedef Pointer = int;

/// Typed wrappers around the symbols exported by SQLite.
///
/// Generated by `tool/generate_bindings.dart`.
extension type SqliteExports(JSObject raw) implements JSObject {
''');

  void writeType(Type type) {
    const bigIntInJs = ['Int64', 'Uint64', 'Long'];

    switch (type) {
      case PointerType():
        buffer.write('Pointer /*<${type.getNativeType().trim()}>*/');
        return;
      case NativeType():
        if (bigIntInJs.contains(type.toString())) {
          buffer.write('JSBigInt');
          return;
        }
      case ImportedType():
        if (bigIntInJs.contains(type.cType)) {
          buffer.write('JSBigInt');
          return;
        }
    }

    buffer.write(type.getDartType(library.writer));
  }

  for (final binding in library.bindings) {
    final mayBeAbsent = !stableFunctions.contains(binding.originalName);

    switch (binding) {
      case Func():
        buffer.write('external ');
        if (mayBeAbsent) {
          buffer.writeln('JSFunction? get ${binding.originalName};');
        } else {
          final type = binding.functionType;
          writeType(type.returnType);
          buffer.write(' ${binding.originalName}(');

          for (final (i, arg) in type.parameters.indexed) {
            if (i != 0) {
              buffer.write(', ');
            }

            writeType(arg.type);
            buffer.write(' ${arg.name}');
          }

          buffer.writeln(');');
        }

      case Global():
        var jsType = 'Global';
        if (mayBeAbsent) {
          jsType += '?';
        }

        buffer
          ..write('external $jsType get ')
          ..write(binding.originalName)
          ..writeln(';');
    }
  }

  buffer.writeln('}');

  final formatter = DartFormatter(languageVersion: Version(3, 10, 0));
  File(
    'lib/src/wasm/sqlite3_wasm.g.dart',
  ).writeAsStringSync(formatter.format(buffer.toString()));
}

void writeUsedSymbols() {
  final buffer = StringBuffer('''
// Generated by tool/generate_bindings.dart
// Used to generate a linker script hiding functions we don't need.

// dart format off
const usedSqliteSymbols = {
''');
  final library = ffigen.parse(
    Config(
      output: Uri.parse('unused'),
      entryPoints: [Uri.parse('assets/sqlite3.h')],
      functionDecl: _includeSqlite3Only,
      globals: _includeSqlite3Only,
    ),
  );

  for (final binding in library.bindings) {
    if (binding is Global || binding is Func) {
      buffer.writeln("  '${binding.originalName}',");
    }
  }

  buffer.writeln('};');
  File('lib/src/hook/used_symbols.dart').writeAsString(buffer.toString());
}
