import 'dart:io';

import 'package:collection/collection.dart';
import 'package:crypto/crypto.dart';
import 'package:path/path.dart' as p;

/// A GH actions step will download all sqlite3 binaries attached to a release
/// to `sqlite/out`.
///
/// This program replaces `sqlite3/lib/src/hook/asset_hashes.dart` to reference
/// those hashes.
///
/// When given an argument, that is interpreted as a tag name about to be
/// released. It asserts the source matches what this script would generate.
void main(List<String> args) {
  final releaseTag = switch (args) {
    [] => null,
    [final arg] => arg,
    _ => throw ArgumentError.value(
        args.join(' '), 'args', 'Must be empty or the tag'),
  };

  final buffer = StringBuffer('''
// This file contains hashes of SQLite binaries downloaded by the default hook.
// For tests, it is replaced with actual assets. For releases, a pre-release
// check asserts it's up-to-date.
//
// Generated by tool/write_asset_hashes.dart

// dart format off
// ignore: unnecessary_nullable_for_final_variable_declarations
const String? releaseTag = ${releaseTag == null ? 'null' : "'$releaseTag'"};

const Map<String, String> assetNameToSha256Hash = {
''');

  final files = Directory('sqlite/out').listSync().whereType<File>().toList();
  files.sortBy((f) => f.path);

  for (final file in files) {
    final name = p.basename(file.path);
    final hash = sha256.convert(file.readAsBytesSync());

    buffer.writeln("  '$name': '$hash',");
  }

  buffer.writeln('};');

  print(buffer);

  final targetFile =
      File(p.join('sqlite3', 'lib', 'src', 'hook', 'asset_hashes.dart'));
  if (releaseTag == null) {
    targetFile.writeAsStringSync(buffer.toString());
  } else {
    final actual = targetFile.readAsStringSync();
    if (actual != buffer.toString()) {
      print('Contents did not match expected outputs');
      exit(1);
    }
  }
}
